


1.burp 
extensions to install: 
Extender>BApp store>Reflected Parameters>Install
Extender>BApp store>Param Miner>Install
Extender>BApp store>Param authorize>Install
Extender>BApp store>Param autorepeater>Install
	ssrf reg: https?:\/\/(www\.)?[-a-zA-Z0–9@:%._\+~#=]{1,256}\.[a-zA-Z0–9()]{1,6}\b([-a-zA-Z0–9()@:%_\+.~#?&//=]*)
https://github.com/CoreyD97/BurpCustomizer/releases?source=post_page-----9cb181443464---------------------------------------
 Extender>BApp store>Burp Suite Scanner
 spider
 logger++

2.k_automation
./testing.sh (ensure we have live.txt)



4.cves 
refer cves/testing.txt


3.nuclei  and jaeles




5.individual testing =>see below

-------------------------------------------------------------------1.AUTOMATION RUN BASED ON DOMAIN,SUBDOMAIN-------------------------------------------------------------------

1.run on domain name and subdomains names:

//nuclei
nuclei -l livedomains.txt  -s critical,high,medium,low,info -o nuclei_domain1_out
nuclei -l livedomains.txt  -t /home/maddy/techiee/bug_bounty/2_phase_recon_autom/automation/nuclei-temp/downloaded_all_nucleitemplates/ -s critical,high,medium,low -o nuclei_domain2_out
nuclei -l livedomains.txt  -t /home/maddy/techiee/bug_bounty/2_phase_recon_autom/automation/nuclei-temp/lostsec/ -s critical,high,medium,low -o nuclei_domain3_out
nuclei -l domains.txt -t /home/maddy/nuclei-templates/http/misconfiguration -o nuclei_domain4.txt

//jaeles
jcat livedomains.txt| jaeles scan
//output:out

2.run on js files:
//nuclei
nuclei -l jsurls.txt -s critical,high,medium,low -o nuclei_js1_out
nuclei -l jsurls.txt -t /home/maddy/techiee/bug_bounty/2_phase_recon_autom/automation/nuclei-temp/downloaded_all_nucleitemplates/ -s critical,high,medium,low -o nuclei_js2_out
nuclei -l jsurls.txt  -t /home/maddy/techiee/bug_bounty/2_phase_recon_autom/automation/nuclei-temp/lostsec/ -s critical,high,medium,low -o nuclei_js3_out
nuclei -l jsurls.txt -s critical,high,medium,low -t /home/maddy/nuclei-templates/javascript -o nuclei_js4_out
nuclei -l jsurls.txt -s critical,high,medium,low -t /home/maddy/nuclei-templates/http/exposures -o nuclei_js5_out

//jaeles
jcat jsurls.txt| jaeles scan

----------------------------------2.AUTOMATION RUN ON SPECIFIC URLS ACC TO VULNERABILITY : (RUN SPCIFIC TEMPLATES ALSO RUN ALL TEMPLATES...)----------------------------------------


2..GETTING PARAMETERIZED URLS:

	1.ParamSpider (Spidering + Regex):
	getting urls: paramspider -l livedomains.txt 
	       
	 2.Regex: 
	 cat all_urls.txt | grep -E '\?[^=]+=.+$' >>regex.txt (will identify all parametrized outputs)

	3.use lostfuzzer.sh:
	/home/maddy/techiee/bug_bounty/2_phase_recon_autom/tools/lostfuzzer.sh
        mv filtered_urls.txt loxs_param.txt

	combining all prams_urls:
	cat  out/* regex.txt loxs_param.txt | sort -u >> all_params.txt and use this in sql,xss,openredirection testing


# running nuclei,jaeles in parametrized urls...

//nuclei


nuclei -l all_params.txt  -s critical,high,medium,low -o nuclei_param1_out
nuclei -l all_params.txt -t /home/maddy/techiee/bug_bounty/2_phase_recon_autom/automation/nuclei-temp/downloaded_all_nucleitemplates/ -s critical,high,medium,low -o nuclei_param2_out
nuclei -l all_params.txt  -t /home/maddy/techiee/bug_bounty/2_phase_recon_autom/automation/nuclei-temp/lostsec/ -s critical,high,medium,low -o nuclei_param3_out
nuclei -l all_params.txt -t /home/maddy/nuclei-templates/dast -s critical,high,medium,low -o nuclei_param4_out

//jaeles
jcat all_params.txt| jaeles scan
//output:out


-------------------------------------------------------------------GENERAL BUGS AUTOMATION: (input: filtered_params_urls)
SQLI,XSS AND OD AUTOMATION:


#FINDING HIDDEN PARAMS (if result found then we can test for vuln according to hidden parameter)
	cat params.txt | xargs -I % arjun -u "%" -oT hidden_params.txt
	while read url; do   echo "[$(date '+%T')] Scanning: $url" | tee -a hidden_params.txt;   echo "==== URL: $url ====" >> hidden_params.txt;   arjun  --stable -u "$url" -oT - >> hidden_params.txt;   echo -e "\n" >> hidden_params.txt;   sleep 2; done < params.txt

[[[ Check for reflection of that hidden param in response and understnad the role of that parameter,

Use tools like Burp Suite or Postman to intercept requests and modify hidden parameters.

Test for input validation issues (e.g., SQLi payloads, XSS payloads).

Check if changing the param affects authorization (e.g., access to other user’s data).

Try injecting payloads relevant to command injection or other vulnerabilities. ]]]]



### **SQL Injection (SQLi) Automation**

        1.using sqlmap:
	sqlmap -m all_params.txt --level 5 --risk 3 --batch --dbs --tamper=between --random-agent
		
	
	3.nuclei: (input: filtered_params_urls)
	nuclei -tags sqli,injection,error,blind,time,post,database,mysql,postgresql,mssql,azure-sql,google-cloud-sql,dast  -rate-limit 200 -retries 2 -l all_params.txt -o sqli_results.txt

	

### **Cross-Site Scripting (XSS) Automation**

	1.using dalfox. (input: filtered_params_urls)
	dalfox file all_params.txt --deep --blind xss.yourdomain.com
	dalfox -b <payload> file all_params.txt


	2.cat all_params.txt | qsreplace '"/><script>confirm(1)</script>' > xss.txt && \
while read host; do
  echo "Testing: $host"
  if curl --silent --path-as-is --insecure "$host" | grep -q "<script>confirm(1)</script>"; then
    echo -e "$host [VULNERABLE]" | tee -a xss_results.txt
  else
    echo -e "$host [Not Vulnerable]" | tee -a xss_results.txt
  fi
done < xss.txt


### **Server-Side Request Forgery (SSRF) Automation**


        1.using qsreplace and ffuf : (input: filtered_params_urls)
	# Replace all query parameters with Burp Collaborator URL for SSRF detection
	cat params_url.ssrf | qsreplace <burp-collab> | tee ssrf_urls_ffuf
	# Perform SSRF scanning using ffuf
	ffuf -c -w ssrf_urls_ffuf -u FUZZ
	
	2.using nuclei: (input: filtered_params_urls)
		=>for blind ssrf:  cat or.txt | nuclei -t /prsnl/blind-ssrf.yaml  --retiries 2 --dast
		=>for ssrf:   cat or.txt | nuclei -t /prsnl/response-ssrf.yaml --retiries 2 --dast


### **Open Redirect (OD) Automation**

getting urls:
cat final.txt | grep -Pi "returnUrl=|continue=|dest=|destination=|forward=|go=|goto=|login\?to=|login_url=|logout=|next=|next_page=|out=|g=|redir=|redirect=|redirect_to=|redirect_uri=|redirect_url=|return=|returnTo=|return_path=|return_to=|return_url=|rurl=|site=|target=|to=|uri=|url=|qurl=|rit_url=|jump=|jump_url=|originUrl=|origin=|Url=|desturl=|u=|Redirect=|location=|ReturnUrl=|redirect_url=|redirect_to=|forward_to=|forward_url=|destination_url=|jump_to=|go_to=|goto_url=|target_url=|redirect_link=" | tee redirect_params.txt


usimg httpx:

cat redirect_params.txt | qsreplace "https://evil.com" | httpx-toolkit -silent -fr -mr "evil.com"

cat urls.txt | gf redirect | uro | qsreplace "https://evil.com" | httpx-toolkit -silent -fr -mr "evil.com"


using curl:

 cat urls.txt | qsreplace "https://evil.com" | xargs -I {} curl -s -o /dev/null -w "%{url_effective} -> %{redirect_url}\n" {}
 


using loxs tool:
cat urls.txt | sed 's/=.*/=/' | uro >loxs.txt =>idha ipo loxs toola use pnlaa


using nuclei:
cat subdomains.txt | nuclei -t openRedirect.yaml -c 30


using rust scanner:
cargo build
cargo run
refer automation/tools

aadvanced oneliner:

cat urls.txt | gf redirect | while read url; do
    cat loxs/payloads.txt | while read payload; do
        echo "$url" | qsreplace "$payload" | httpx -silent -fr -mr "google.com"
    done
done


	1.using curl:
	cat params_urls.txt | grep -E '\?[^=]+=.+$' | sed 's/\(.*=\).*/\1https:\/\/evil.com/' | xargs -I {} curl -s -k {}
	2.using nuclei: (input: filtered_params_urls)
	cat or.txt | nuclei -t /prsnl/openredirect.yaml --retries 2




* **Using Curl:**

  ```bash
  cat params_urls.txt | grep -E '\?[^=]+=.+$' | sed 's/\(.*=\).*/\1https:\/\/evil.com/' | xargs -I {} curl -s -k {}
  ```

* **Using Nuclei:**

  ```bash
  cat or.txt | qsreplace "https://evil.com" | anew open_redirects_payloads.txt
  cat open_redirects_payloads.txt | nuclei -t /prsnl/openredirect.yaml --retries 2 -rl 10 -bs 2 -c 2 -as -silent -o result.txt -json result.json -s critical,high
  ```

  * `qsreplace` is used to replace query parameter values with `https://evil.com` to test for open redirects.
  * `anew` ensures no duplicates are present in `open_redirects_payloads.txt`.
  * Nuclei will use `openredirect.yaml` to check for open redirect vulnerabilities.





#rsubdomain takeover:

using nuclei:
nuclei -l livedomains.txt -t /home/maddy/nuclei-templates/http/takeovers -o takeover_out1.txt
nuclei -l livedomains.txtt -t /home/maddy/nuclei-templates/profiles/subdomain-takeovers.yml -o takeover_out2.txt

using subzy:
subzy run --targets domains.txt


#automating wordpress:

nuclei -l livedomains.txt -t /home/maddy/nuclei-templates/http/vulnerabilities/wordpress -o wordpress1_out
cat alive.txt | nuclei -t /home/maddy/nuclei-templates/http/technologies/wordpress-detect.yaml -o wordpress2_out

#automating cors:
nuclei -l domains.txt -tags cors -o nuclei_cors.txt

#-------------------crlf--------------------------
using crlfi:
crlfi -i domains.txt -o crlfi.txt

using crlfuzz:
crlfuzz -l domains.txt | tee -a output.txt
crlfuzz -l urls.txt | tee -a output.txt

using crlfsuite:
crlfsuite -iT domains.txt


about ax framework,ax tool for automation
